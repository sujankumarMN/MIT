$date
    Nov 10, 2022  16:19:04
$end
$version
    TOOL:	ncsim(64)	15.20-s086
$end
$timescale
    1 ns
$end

$scope module basic_ram_tb $end
$var reg       1 !    cs  $end
$var reg       1 "    clk  $end
$var reg       1 #    we  $end
$var reg       1 $    oe  $end
$var reg       2 %    addr_row [1:0] $end
$var reg       2 &    addr_col [1:0] $end
$var reg       4 '    datain [3:0] $end
$var wire      4 (    dataout [3:0] $end
$var wire      1 )    mem [3][3][3] $end
$var wire      1 *    mem [3][3][2] $end
$var wire      1 +    mem [3][3][1] $end
$var wire      1 ,    mem [3][3][0] $end
$var wire      1 -    mem [3][2][3] $end
$var wire      1 .    mem [3][2][2] $end
$var wire      1 /    mem [3][2][1] $end
$var wire      1 0    mem [3][2][0] $end
$var wire      1 1    mem [3][1][3] $end
$var wire      1 2    mem [3][1][2] $end
$var wire      1 3    mem [3][1][1] $end
$var wire      1 4    mem [3][1][0] $end
$var wire      1 5    mem [3][0][3] $end
$var wire      1 6    mem [3][0][2] $end
$var wire      1 7    mem [3][0][1] $end
$var wire      1 8    mem [3][0][0] $end
$var wire      1 9    mem [2][3][3] $end
$var wire      1 :    mem [2][3][2] $end
$var wire      1 ;    mem [2][3][1] $end
$var wire      1 <    mem [2][3][0] $end
$var wire      1 =    mem [2][2][3] $end
$var wire      1 >    mem [2][2][2] $end
$var wire      1 ?    mem [2][2][1] $end
$var wire      1 @    mem [2][2][0] $end
$var wire      1 A    mem [2][1][3] $end
$var wire      1 B    mem [2][1][2] $end
$var wire      1 C    mem [2][1][1] $end
$var wire      1 D    mem [2][1][0] $end
$var wire      1 E    mem [2][0][3] $end
$var wire      1 F    mem [2][0][2] $end
$var wire      1 G    mem [2][0][1] $end
$var wire      1 H    mem [2][0][0] $end
$var wire      1 I    mem [1][3][3] $end
$var wire      1 J    mem [1][3][2] $end
$var wire      1 K    mem [1][3][1] $end
$var wire      1 L    mem [1][3][0] $end
$var wire      1 M    mem [1][2][3] $end
$var wire      1 N    mem [1][2][2] $end
$var wire      1 O    mem [1][2][1] $end
$var wire      1 P    mem [1][2][0] $end
$var wire      1 Q    mem [1][1][3] $end
$var wire      1 R    mem [1][1][2] $end
$var wire      1 S    mem [1][1][1] $end
$var wire      1 T    mem [1][1][0] $end
$var wire      1 U    mem [1][0][3] $end
$var wire      1 V    mem [1][0][2] $end
$var wire      1 W    mem [1][0][1] $end
$var wire      1 X    mem [1][0][0] $end
$var wire      1 Y    mem [0][3][3] $end
$var wire      1 Z    mem [0][3][2] $end
$var wire      1 [    mem [0][3][1] $end
$var wire      1 \    mem [0][3][0] $end
$var wire      1 ]    mem [0][2][3] $end
$var wire      1 ^    mem [0][2][2] $end
$var wire      1 _    mem [0][2][1] $end
$var wire      1 `    mem [0][2][0] $end
$var wire      1 a    mem [0][1][3] $end
$var wire      1 b    mem [0][1][2] $end
$var wire      1 c    mem [0][1][1] $end
$var wire      1 d    mem [0][1][0] $end
$var wire      1 e    mem [0][0][3] $end
$var wire      1 f    mem [0][0][2] $end
$var wire      1 g    mem [0][0][1] $end
$var wire      1 h    mem [0][0][0] $end

$scope module dut $end
$var wire      1 i    cs  $end
$var wire      1 j    clk  $end
$var wire      1 k    we  $end
$var wire      1 l    oe  $end
$var wire      2 m    addr_row [1:0] $end
$var wire      2 n    addr_col [1:0] $end
$var wire      4 o    datain [3:0] $end
$var reg       4 p    dataout [3:0] $end
$upscope $end

$upscope $end

$enddefinitions $end
$dumpvars
0!
0"
0#
0$
bx %
bx &
bx '
bx (
x)
x*
x+
x,
x-
x.
x/
x0
x1
x2
x3
x4
x5
x6
x7
x8
x9
x:
x;
x<
x=
x>
x?
x@
xA
xB
xC
xD
xE
xF
xG
xH
xI
xJ
xK
xL
xM
xN
xO
xP
xQ
xR
xS
xT
xU
xV
xW
xX
xY
xZ
x[
x\
x]
x^
x_
x`
xa
xb
xc
xd
xe
xf
xg
xh
0i
0j
0k
0l
bx m
bx n
bx o
bx p
$end
#5
1"
1j
#10
0"
0j
#12
1#
b110 '
b11 %
b1 &
b1 n
b11 m
b110 o
1k
#15
1"
1j
#20
0"
0j
#25
1!
1"
1j
1i
01
12
13
04
#30
0"
0j
#35
1"
1j
#40
0#
0"
0j
0k
#45
1"
1j
#50
1$
0"
0j
1l
#55
1"
1j
b110 p
b110 (
#60
0"
0j
#65
1"
1j
#70
0"
0j
#75
1"
1j
#80
0"
0j
#85
1"
1j
#90
0"
0j
#95
1"
1j
#100
